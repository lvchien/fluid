include "getARGV.idp"
include "solvers.edp"

real Pr = getARGV("--Pr", 1.0);																                                // the Prandtl number
real tf = getARGV("--tf", 5e-2);																	                            // the final time
string outputFolder = getARGV("--resu", "results/analytical_solution");
real Ra = 1;                                                                                  // the Rayleigh number

cout << "Results and figures will be saved in " << outputFolder << endl;
system("mkdir \""+outputFolder+"\"");

/* Save commands */
ofstream cmd(outputFolder+"/command.sh");
for (int ii = 0; ii < ARGV.n; ii++)
  cmd << ARGV[ii] << " ";
cmd << endl;
cmd.flush;

ofstream re(outputFolder + "/demo.txt");
re << "Pr^-1\ttf\t\tn\th\tdt\t 2_T_error\t2_T_rate\t2_u_error\t2_u_rate\t 1_T_error\t1_T_rate\t1_u_error\t1_u_rate\t 0_T_error\t0_T_rate\t0_u_error\t0_u_rate" << endl;

int n;                                                  
real errT2 = 0, errTp2 = 0, erru2 = 0, errup2 = 0, errT1 = 0, errTp1 = 0, erru1 = 0, errup1 = 0, errT0 = 0, errTp0 = 0, erru0 = 0, errup0 = 0;

real[int] iter(12); 
iter = [10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000];                    // number of time intervals

for(int j = 0; j <= 11; j++)
{
  for(int k=2;k<=7;k++)
  {
    /* Generate square mesh */
    n= 2^k;
    mesh Th=square(n,n);

    // Difine finite element spaces
    fespace Xh(Th,P2);
    fespace Mh(Th,P1);

    // Declare initial solutions (at t = 0) of thermal and velocity
    Xh T = 0.5*pi*sin(2*pi*y);
    Xh u1 = -cos(pi*x)*sin(pi*y);
    Xh u2 = sin(pi*x)*cos(pi*y);

    // Exact solutions of thermal and velocity at final time
    func Te = 0.5*pi*sin(2*pi*y)*exp(-4*pi^2*tf*Pr);
    func u1e = -cos(pi*x)*sin(pi*y)*exp(-2*pi^2*tf*Pr);
    func u2e = sin(pi*x)*cos(pi*y)*exp(-2*pi^2*tf*Pr);

    // Declare variables
    Xh Qn,vbc1x,vbc1y,vbc2x,vbc2y,vbc3x,vbc3y,vbc4x,vbc4y,tbc1,tbc2,tbc3,tbc4;
    Xh up1,up2,v2,v1,v,Told;
    Mh p,q;
    real t;

    real epsr = 1e-8;
    real dt = 1.*tf/iter[j];
    real alpha = 1./dt;
    int i=0;

    for (i=0;i<=iter[j];i++)
    {
      t=i*dt;
      Qn = (1.-1.*Pr)*2*pi^3*sin(2*pi*y)*exp((-4*pi^2*t)*Pr) + pi*pi*sin(pi*x)*cos(pi*y)*cos(2*pi*y)*exp((-6*pi*pi*t)*Pr);

      tbc1 = 0;
      tbc2 = 0.5*pi*sin(2*pi*y)*exp(-4*pi*pi*t*Pr);
      tbc3 = 0;
      tbc4 = 0.5*pi*sin(2*pi*y)*exp(-4*pi*pi*t*Pr);

      vbc1x = 0;
      vbc1y = sin(pi*x)*exp(-2*pi*pi*t*Pr);
      vbc2x = -cos(pi)*sin(pi*y)*exp(-2*pi*pi*t*Pr);
      vbc2y = sin(pi)*cos(pi*y)*exp(-2*pi*pi*t*Pr);
      vbc3x = -cos(pi*x)*sin(pi)*exp(-2*pi*pi*t*Pr);
      vbc3y = sin(pi*x)*cos(pi)*exp(-2*pi*pi*t*Pr);
      vbc4x = -sin(pi*y)*exp(-2*pi*pi*t*Pr);
      vbc4y = 0;
 
      Told=T;
      up1=u1;
      up2=u2;
      LTD;
      NS;
    }

    // Calculate errors and corresponding convergence rates
    Xh dT = T-Te, du1 = u1-u1e, du2 = u2-u2e;
    errTp2 = errT2;
    errup2 = erru2;
    errTp1 = errT1;
    errup1 = erru1;
    errTp0 = errT0;
    errup0 = erru0;
    errT2 = sqrt(int2d(Th)(dT*dT + dt*(dx(dT)*dx(dT) + dy(dT)*dy(dT))));
    erru2 = sqrt(int2d(Th)(du1*du1 + du2*du2 + Pr*dt*(dx(du1)*dx(du1) + dy(du1)*dy(du1) + dx(du2)*dx(du2) + dy(du2)*dy(du2))));
    errT1 = sqrt(int2d(Th)(dT*dT + (dx(dT)*dx(dT) + dy(dT)*dy(dT))));
    erru1 = sqrt(int2d(Th)(du1*du1 + du2*du2 + (dx(du1)*dx(du1) + dy(du1)*dy(du1) + dx(du2)*dx(du2) + dy(du2)*dy(du2))));
    errT0 = sqrt(int2d(Th)(dT*dT));
    erru0 = sqrt(int2d(Th)(du1*du1 + du2*du2));

    // Print to output file
    re  << 1/Pr << "\t" << tf << "\t" << k << "\t"  << Th.hmax << "\t" << dt 
        << "\t" << errT2 << "\t" << log(errTp2/errT2)/log(2.) << "\t" << erru2 << "\t" << log(errup2/erru2)/log(2.) 
        << "\t" << errT1 << "\t" << log(errTp1/errT1)/log(2.) << "\t" << erru1 << "\t" << log(errup1/erru1)/log(2.) 
        << "\t" << errT0 << "\t" << log(errTp0/errT0)/log(2.) << "\t" << erru0 << "\t" << log(errup0/erru0)/log(2.) << endl;
  
    re.flush;
  }
  
  re << endl;
}