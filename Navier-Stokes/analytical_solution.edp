include "getARGV.idp"
include "solvers.edp"

real nu = getARGV("--nu", 1.0);																                                  // the constant kinematic viscosity of the fluid
real tf = getARGV("--tf", 1.0/320);																	                            // the final time
string outputFolder = getARGV("--resu", "results\analytical_solution");
string filename = getARGV("--filename", "convergence");


cout << "Results and figures will be saved in " << outputFolder << endl;
system("mkdir "+outputFolder);

ofstream re(outputFolder + "/" + filename +".txt");
re << "nu\ttf\tn\th\tdt\tu_error_2\tu_rate_2\tu_error_1\tu_rate_1\tu_error_0\tu_rate_0" << endl;

int n;                                                  
real erru2 = 0, errup2 = 0, erru1 = 0, errup1 = 0, erru0 = 0, errup0 = 0;

real[int] iter(9); 
iter = [10, 20, 50, 100, 200, 500, 1000, 2000, 5000];                                                     // number of time intervals

for(int j = 7; j <= 8; j++)
{
  for(int k=2;k<=7;k++)
  {
    // Generate square mesh 
    n= 2^k;
    mesh Th=square(n,n);

    // Difine finite element spaces
    fespace Xh(Th,P1b);
    fespace Mh(Th,P1);

    // Declare initial solutions (at t = 0) of thermal and velocity
    Xh ux = -cos(pi*x)*sin(pi*y);
    Xh uy = sin(pi*x)*cos(pi*y);

    // Exact solutions of velocity at final time
    func uxe = -cos(pi*x)*sin(pi*y)*exp(-2*pi^2*tf*nu);
    func uye = sin(pi*x)*cos(pi*y)*exp(-2*pi^2*tf*nu);

    // Declare variables
    Xh dcx1,dcx2,dcx3,dcx4,dcy1,dcy2,dcy3,dcy4;
    Xh upx,upy,vx,vy;
    Xh fx = 0, fy = 0;
    Mh p,q;
    real t;

    real epsr = 1e-8;
    real dt = 1.*tf/iter[j];
    real alpha = 1./dt;
    int i=0;

    for (i=0;i<=iter[j];i++)
    {
      t=i*dt;

      dcx1 = 0.0;
      dcx2 = sin(pi*y)*exp(-2*pi^2*t*nu);
      dcx3 = 0.0;
      dcx4 = -sin(pi*y)*exp(-2*pi^2*t*nu);

      dcy1 = sin(pi*x)*exp(-2*pi^2*t*nu);
      dcy2 = 0.0;
      dcy3 = -sin(pi*x)*exp(-2*pi^2*t*nu);
      dcy4 = 0.0;

      upx=ux;
      upy=uy;
      NavierStokes;
    }

    // Calculate errors and corresponding convergence rates
    Xh dux = ux - uxe, duy = uy - uye;
    errup2 = erru2;
    errup1 = erru1;
    errup0 = erru0;
    erru2 = sqrt(int2d(Th)(dux*dux + duy*duy + nu*dt*(dx(dux)*dx(dux) + dy(dux)*dy(dux) + dx(duy)*dx(duy) + dy(duy)*dy(duy))));
    erru1 = sqrt(int2d(Th)(dux*dux + duy*duy + (dx(dux)*dx(dux) + dy(dux)*dy(dux) + dx(duy)*dx(duy) + dy(duy)*dy(duy))));
    erru0 = sqrt(int2d(Th)(dux*dux + duy*duy));

    // Print to output file
    re  << nu << "\t" << tf << "\t" << k << "\t"  << Th.hmax << "\t" << dt 
        << "\t" << erru2 << "\t" << log(errup2/erru2)/log(2.) 
        << "\t" << erru1 << "\t" << log(errup1/erru1)/log(2.) 
        << "\t" << erru0 << "\t" << log(errup0/erru0)/log(2.) << endl;
  }
  erru2 = 0; 
  erru1 = 0;
  erru0 = 0;
  re << endl;
}
re.flush;