include "getARGV.idp"
include "solvers.edp"
load "medit";

int config = getARGV("--config", 1);                        // the case of test (1, 2 or 3)
int dc = getARGV("--dc", 1);                                // the config of DC methods (1 for DC or 0 for not DC)
real nu = getARGV("--nu", 1e-3);                            // nu parameter
real T = getARGV("--T", 100);                               // the final time (second)
real dt = getARGV("--dt", 0.01);;                           // the time step (second)
real sigma = getARGV("--sigma", 0.4*Th.hmax);               // the stabilizing factor of defect-correction method
int nbp = getARGV("--nbp", 100);                            // the number of points in vertical and horizontal lines

// Make output
string outputFolder = getARGV("--resu", "results\Lid-driven cavity");
cout << "Results and figures will be saved in " << outputFolder << endl;
system("mkdir "+outputFolder);

// Save the command 
ofstream cmd(outputFolder+"/command.sh");
for (int ii = 0; ii < ARGV.n; ii++)
  cmd << ARGV[ii] << " ";
cmd << endl;
cmd.flush;

// Load computational mesh
mesh Th;
string meshname = "meshes/mesh"+config+".mesh";
cout << "Loading mesh " << meshname << "...";
Th = readmesh(meshname);
cout << "done." << endl;
cout.flush;

// Finite element spaces
fespace Xh(Th,P2);                                                          // definition of the velocity component space
fespace Mh(Th,P1);                                                          // definition of the pressure space

// Declare variables
Xh ux, uy, vx, vy, upx, upy, uppx, uppy, u0x, u0y, up0x, up0y;
Xh clx, cly, w, psi, phi;
Mh p,q, p0;

Xh fx = 0.0, fy = 0.0;
real alpha = 1.0/dt;
int i = 0;
int imax = T/dt;


// Set boundary conditions
if(config == 1)                                 // Lid - driven cavity
{
    clx = 1;
    cly = 0;
}
else if(config == 2)                            // Backward facing step
{
    clx = (8.0/3.0)*y*(1-y);
    cly = 0;
}
else if (config == 3)                           // Flow around cylinder
{                     
    real D = 0.1, H = 0.41;
    real Um = 150;
    clx = 4.*Um*y*(H-y)/(H*H);
    cly = 0.;
    int nn = getARGV("--nn", 15);               // number of meshing points                  
    dt = D/nn/Um;
}
else if(config == 4)                            // Cylinder Stokes
{
    real D = 0.1, H = 0.41;
    real Um = 1.5;
    clx = 4.*Um*y*(H-y)/(H*H);
    cly = 0.;
}

if (config == 4)
{
    Stokes;
    Streamlines;
    w = - dy(ux) + dx(uy);

    plot([ux, uy], cmm = "Velocity");
    plot(p, cmm = "Pressure");	
    plot(w, cmm = "Vorticity");		
    plot(psi, cmm = "Streamlines");		

    savesol(outputFolder+"/velocity.sol", Th, [ux, uy]);		
    savesol(outputFolder+"/pressure.sol", Th, p);
    savesol(outputFolder+"/vorticity.sol", Th, w);
    savesol(outputFolder+"/streamlines.sol", Th, psi);
}
else
{
    for (i = 1; i <= imax; i++)
    {
        uppx = upx;
        uppy = upy;
        upx = ux;
        upy = uy;
		up0x = u0x;
        up0y = u0y;

        if(dc==0)
            NS1stOrder;
        else if(dc==1)
            NS1stOrderDC;
            
        Streamlines;
        w = -dy(ux) + dx(uy);

        if(i % 100 == 0)
        {
            plot([ux, uy], cmm="Velocity: iteration "+i+"/"+imax);
			plot(p, cmm="Pressure: iteration "+i+"/"+imax);	
			plot(w, cmm="Vorticity: iteration "+i+"/"+imax);		
			plot(psi, cmm="Streamlines: iteration "+i+"/"+imax);			

            savesol(outputFolder+"/velocity." + i/100 + ".sol", Th, [ux, uy]);		
            savesol(outputFolder+"/pressure." + i/100 +".sol", Th, p);
            savesol(outputFolder+"/vorticity." + i/100 + ".sol", Th, w);
            savesol(outputFolder+"/streamlines." + i/100 + ".sol", Th, psi);
        }
    }
}


// Get velocity of flow at points in vertical and horizontal lines that pass center of cavity
real dd = 1.0/nbp;

ofstream fx(outputFolder + "/xprof");
for(i = 0; i <= nbp; i++)
    fx << i*dd << " " << ux(0.5, i*dd) << endl;
fx.flush;

ofstream fy(outputFolder + "/yprof");
for(i = 0; i <= nbp; i++)
    fy << i*dd << " " << uy(i*dd, 0.5)  << endl;
fy.flush;


// Find center of primary vortex
real minx = 0.5;
real maxx = 0.8;
real miny = 0.5;
real maxy = 0.8;

real centerx = minx;
real centery = miny;

int ni = getARGV("--ni", 300);
real slx = (maxx - minx)/ni;
real sly = (maxy - miny)/ni;

real minu = ux(minx, miny)^2 + uy(minx, miny)^2;

for (int j = 1; j <= ni; j++)
    for(int k = 1; k <= ni; k++)
    {
        real tempx = minx + j*slx;
        real tempy = miny + k*sly;
        real tempu = ux(tempx, tempy)^2 + uy(tempx, tempy)^2;
        if(tempu < minu)
            {
                minu = tempu;
                centerx = tempx;
                centery = tempy;
            }
    }

ofstream ct(outputFolder + "/center.txt");
ct << centerx << " " << centery  << endl;
ct.flush;